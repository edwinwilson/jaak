/**
 * 
 */
package io.sarl.jaak.environment.internal.model;

import io.sarl.jaak.environment.external.body.TurtleBody;
import io.sarl.jaak.environment.external.endogenous.AutonomousEndogenousProcess;
import io.sarl.jaak.environment.external.influence.Influence;
import io.sarl.jaak.environment.external.perception.Burrow;
import io.sarl.jaak.environment.external.perception.EnvironmentalObject;
import io.sarl.jaak.environment.external.perception.ObjectManipulator;
import io.sarl.jaak.environment.external.perception.Substance;
import io.sarl.jaak.environment.internal.ContinuousModel;
import io.sarl.jaak.environment.internal.solver.ActionApplier;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;

import org.arakhne.afc.math.continous.object2d.Vector2f;
import org.jbox2d.common.Vec2;
import org.jbox2d.dynamics.Body;
import org.jbox2d.dynamics.World;

/**
 * This class defines a wrapper of the JBox2d world. All methods interacting
 * directly with JaBox2D world should be defined here.
 * 
 * @author Edwin Wilson
 *
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
public class JaakContinuousWorld implements ContinuousModel, ActionApplier {

	private final Map<UUID, Body> bodies = new TreeMap<>();
	private final Map<UUID,Body> environmentObjectBodies = new TreeMap<>();
	private World world;
	private float width;
	private float height;
	private ObjectManipulator objectManipulator;
	private WeakReference<JaakEnvironment> environmentRef;
	private final Collection<AutonomousEndogenousProcess> autonomousProcesses = new LinkedList<>();
	
	public JaakContinuousWorld(JaakEnvironment env){
		Vec2 gravity = new Vec2(0,1);
		boolean doSleep = true;
		world = new World(gravity);
		this.environmentRef = new WeakReference<JaakEnvironment>(env);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see io.sarl.jaak.environment.internal.ContinuousModel#getWidth()
	 */
	@Override
	public float getWidth() {
		return this.width;
	}

	public World getWorld() {
		return world;
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see io.sarl.jaak.environment.internal.ContinuousModel#getHeight()
	 */
	@Override
	public float getHeight() {
		return this.height;
	}

	@Override
	public boolean removeTurtle(UUID turtleId) {

		if (!this.bodies.containsKey(turtleId)) {
			return false;
		}
		this.world.destroyBody(bodies.get(turtleId));
		this.bodies.remove(turtleId);
		return true;
	}

	@Override
	public boolean setPhysicalState(float x, float y, float heading, float speed, Vector2f linearVelocity, TurtleBody emitter) {
		if (emitter instanceof RealTurtleBody) {
			((RealTurtleBody) emitter).setPhysicalState(x, y, heading, speed, linearVelocity);
			return true;
		}
		return false;
	}
	
	/** Run the autonomous environmental processes.
	 *
	 * @param currentTime is the current simulation time
	 * @param simulationStepDuration is the duration of the current simulation step.
	 * @return the influences generated by the autonomous processes.
	 */
	public synchronized Collection<Influence> runAutonomousProcesses(float currentTime, float simulationStepDuration) {
		Collection<Influence> influences = new LinkedList<>();
		Influence influence;
		for (AutonomousEndogenousProcess process : this.autonomousProcesses) {
			influence = process.runAutonomousEndogenousProcess(currentTime, simulationStepDuration);
			if (influence != null) {
				influences.add(influence);
			}
		}
		return influences;
	}


	@Override
	public EnvironmentalObject removeObject(EnvironmentalObject pickUpObject) {
		EnvironmentalObject change = null;
		UUID id = pickUpObject.getId();
		
		if (pickUpObject instanceof Substance) {
			Substance oldSubstance = (Substance) pickUpObject;

			EnvironmentalObject oldObject = environmentRef.get().getEnvironmentalObject(id);
			if (oldObject instanceof Substance) {
				Substance currentSubstance = (Substance) oldObject;
				change = this.objectManipulator.combine(currentSubstance, oldSubstance, false);
				if (change == null || !currentSubstance.isDisappeared()) {
					return change;
				}
			}
		}

		EnvironmentalObject obj;

		obj = environmentRef.get().removeEnvironmentalObject(id);
		this.environmentObjectBodies.remove(id);

		if (obj != null) {
			if (change == null) {
				change = obj;
			}
			if (obj instanceof Burrow) {
				deleteBurrow(id);
			}
			this.objectManipulator.setPosition(obj, Integer.MIN_VALUE,
					Integer.MIN_VALUE);
			if (obj instanceof AutonomousEndogenousProcess) {
				this.autonomousProcesses.remove(obj);
			}
		}
		return change;
	}

	private void deleteBurrow(UUID id) {
		Body body = environmentObjectBodies.get(id);
		world.destroyBody(body);
		if(environmentObjectBodies.containsKey(id)){ environmentObjectBodies.remove(id);}
		environmentRef.get().removeEnvironmentalObject(id);
	}

	@Override
	public void putObject(float x, float y, EnvironmentalObject dropOffObject) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean putTurtle(float x, float y, TurtleBody emitter) {
		// TODO Auto-generated method stub
		return false;
	}

}
